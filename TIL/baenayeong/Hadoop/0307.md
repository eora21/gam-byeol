
# GFS Architecture

(하둡의 모티브가 된 아키텍처로 하둡도 이 구조를 따라감)

분산 플랫폼들의 아키텍처는 **master-slave 구조**와 **master가 없는 구조**로 나뉠 수 있다.

- master-slave 구조
    - 슬레이브가 마스터의 관리를 받는다.
    - 슬레이브 서버들은 확장(scale-out)해나갈 수 있다.
    - GFS Architecture가 해당된다. 즉, 하둡도 master-slave 구조이다.
- master가 없는 구조
    - 마스터가 가지고 있어야 하는 정보들을 모든 노드가 공유한다.

![image](https://user-images.githubusercontent.com/55578809/157000617-a3ad0424-ac07-4dbc-ae08-59ced9331c5f.png)

- GFS master: 마스터
- GFS chunkserver: 슬레이브
- 슬레이브가 여러 대로 확장될 수 있는 구조
- 마스터는 슬레이브들을 관리해준다.
- 마스터-슬레이브 구조는 마스터에 부하가 가지 않는 상황을 만들어주는 게 중요하다. 마스터가 죽으면 모든 슬레이브들까지 사용을 할 수 없기 때문이다.
    - chunk data: 클라이언트와 슬레이브가 직접 연결되도록 한다 → **클라이언트와 마스터가 통신할 일이 없도록!**

# 하둡

## 하둡의 특징

1. 수천 대 이상의 리눅스 기반 범용 서버들을 하나의 클러스터로 사용한다.
2. 마스터-슬레이브 구조를 갖는다.
3. 파일을 블록 단위로 저장한다.
4. 블록 데이터의 복제본 유지로 인한 신뢰성 보장 (기본 3개의 복제본을 갖는다)
    
    → **개발자가 복제하라는 명령을 내리지 않아도 하둡 플랫폼에서 자체적으로 복제를 한다**.
    
5. 높은 내고장성(Fault-Tolerance)
    
    → 한 서버가 장애가 났다고 해서 데이터가 손실되는 일은 없다는 의미.
    
    → 복제본을 만들어서 여러 군데에 저장하기 때문에 한 서버에 장애가 났다고 데이터가 손실되지는 않는다.
    
6. 데이터 처리의 지역성 보장
    
    → 아래에서 설명
    

## 하둡의 구조

- **강의에서 하둡 한두대는 의미가 없다고 하는데 왜 의미가 없다는지 모르겠다.**

### 블록

- 하나의 파일을 하둡에 저장한다고 했을 때, 하둡이 스스로 여러 개의 파일들로 쪼갠다. → 이 **쪼개어진 단위**들을 블록이라고 한다.
    
    ![image](https://user-images.githubusercontent.com/55578809/157000648-39616db0-934d-4098-b446-f663d485eafd.png)
    
- 저장되는 블록의 크기는 설정에 따라서 달라진다. 보통 128MB 정도의 **큰 크기로 나누어서 저장**한다.
    - 블록 크기가 128MB보다 적은 경우는 128MB가 아니라 실제 크기 만큼만 용량을 차지한다.
- 블록의 크기를 크게 잡았을 때의 장점
    - 블록이 크면 하드 디스크에서 블록의 시작점을 찾을 때 걸리는 시간을 줄일 수 있다.
        
        → 블록을 탐색할 때, 파일의 정보를 최대한 빨리 찾을 수 있다. 
        
    - 네트워크를 통해서 데이터를 전송하는 데 더 많은 시간을 쓸 수 있다.
    - 데이터 처리를 빠르게 할 수 있다.
- **예시**: 분당 24GB 정도 생기는 데이터가 있는 경우
    
    ![image](https://user-images.githubusercontent.com/55578809/157000695-0fddaf65-ac3b-4423-9a3b-475a887d58e4.png)
    
    1. 저장할 파일을 128MB 단위로 여러 블록으로 나눈다.
    2. 블록들을 3개로 복사한다.
    3. 블록들을 슬레이브 서버에 저장한다.
    
    - 마스터 서버에는 데이터를 저장하지 않는다.
        
        네임노드(마스터)는 어떤 블록이 어디에 저장이 된지 알고 있다.
        
        네임노드(마스터)는 3초마다 한번씩 데이터 노드(슬레이브)와 통신하는데 어떤 데이터 노드(슬레이브)에 문제가 생겨서 계속 통신이 안 될 경우, 통신이 안 되는 데이터노드의 블록의 복사본에게 복사본을 하나 더 만들라고 명령을 내린다. 
        
        → 항상 세 개의 복사본이 존재하도록 관리한다. 이 모든 과정을 하둡이 알아서 해준다.
        
    - 세 개의 노드가 동시에 장애가 나지 않는 한 유실이 되지 않는다.

### 블록의 지역성

![image](https://user-images.githubusercontent.com/55578809/157000724-76e38411-7f4a-4bce-93c1-4a48eeae16e3.png)

- 저장된 데이터에 대해 처리하고 싶은 경우
    1. 실제 데이터를 가지고 있는 슬레이브에 job을 할당한다.
    2. 슬레이브의 태스트 트래커는 자신이 가지고 있는 로컬 데이터를 읽어서 처리한다.
        
        → 이걸 블록의 지역성이라고 한다.
        
        →이런 처리를 하는 알고리즘을 개발자가 직접 구현하려면 되게 힘듦. 하둡에서는 이걸 알아서 처리해준다.
        
- 특징
    - 네트워크를 이용한 **데이터 전송 시간 감소**
    - 대용량 데이터 확인을 위한 **디스크 탐색 시간 감소**
    - 적절한 단위의 블록 크기를 이용한 cpu 처리 시간 증가

### 블록 캐싱

- 자주 읽는 블록은 블록 캐시라는 데이터 노드의 메모리에 명시적으로 캐싱할 수 있다.
    - 캐싱: 캐시라고 부르는 좀 더 빠른 메모리 영역으로 데이터를 가져와서 접근하는 방법
- 조인에 사용되는 데이터들을 등록해 읽기 성능을 높일 수도 있다.

### 네임노드(마스터)의 역할

마스터의 역할을 한다.

1. 전체 HDFS에 대한 Name Space 관리
    
    → 어느 블록이 어디에 저장이 되어 있는지 알고 있다.
    
2. 네임노드는 데이터노드로부터 3초에 한번씩 블록들에 대한 보고(리포트)를 받음
3. 데이터 복제를 관리하기 위해서 커맨더 역할 수행
    
    어떤 데이터 노드에 문제가 생겨서 계속 보고를 받지 못하는 경우, 이 보고가 오지 않는 데이터의 복사본을 만들라고 명령을 내림 → 항상 세 개의 복사본이 존재하도록 관리한다. 
    
4. 파일 시스템 이미지 파일 관리 (fsimage)
    - fsimage: 스냅샷을 의미한다.
5. 파일 시스템에 대한 Edit Log 관리
    - **Edit Log**: 운영하는 중 하둡에 생긴 변경 사항들 저장한다.

### 보조 네임 노드 (SNN)

- 네임노드의 메모리는 항상 최신 상태를 유지하도록 되어 있음
- edit log의 변경사항을 전부 **fsimage**에 반영(병합)해준다. 이 병합을 SNN에서 해준다.
- SNN에 장애가 일어나도 파일 시스템에는 아무 문제가 없지만 edit log가 무한히 커져서 하둡 네임노드를 재시작할 때 문제가 생길 수 있다.

### 데이터노드(슬레이브)의 역할

- 슬레이브의 역할을 한다.
- 데이터노드는 물리적으로 로컬 파일 시스템에 HDFS 데이터를 저장한다. → **데이터 노드가 데이터를 저장한다.**
- 마스터 서버한테 내가 가지고 있는 정상적인 블록의 목록을 보고(리포트) 한다.
- 데이터노드는 HDFS에 대한 지식이 없다.

## HDFS 읽기 연산 처리 매커니즘

![image](https://user-images.githubusercontent.com/55578809/157000759-33589bc5-7c22-4fe5-9918-8ee2ef2777be.png)

- 별도 설명 X

## HDFS 쓰기 연산 처리 매커니즘

![image](https://user-images.githubusercontent.com/55578809/157000798-9c516194-17cf-4608-8f55-ca22da39e3f3.png)

1. 파일을 저장할 때 클라이언트가 네임노드에게 파일을 저장할 거라고 요청한다.
2. 네임노드는 파일을 어디에 저장하라고 클라이언트에게 알려준다.
3. 클라이언트와 데이터노드가 통신해서 파일을 저장
4. 데이터 노드들끼리 통신해서 Replication(복제)를 한다.

![image](https://user-images.githubusercontent.com/55578809/157000820-bd204c6e-44b9-490e-a0f7-5b3758fa0db7.png)